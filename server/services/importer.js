const { pool } = require('../config/database');
const DepositService = require('./depositService');
const axios = require('axios');
const orderPaymentService = require('./orderPaymentService');

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω: "–æ—Ç—Å–µ—á—å –¥–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –Ω—É–ª—è —Ç–æ—á–∫–æ–π" –±–µ–∑ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
function formatDropTwoZeros(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  const s = String(Math.trunc(n));
  if (!/^[0-9]+$/.test(s)) return null;
  const whole = s.length > 2 ? s.slice(0, -2) : '0';
  const cents = s.length > 1 ? s.slice(-2).padStart(2, '0') : s.padStart(2, '0');
  return `${whole}.${cents}`;
}

async function fetchWbNewFbs(apiKey) {
  const base = 'https://marketplace-api.wildberries.ru/api/v3';
  const path = '/orders/new';
  try {
    console.log(`üîç FBS: –ø–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–µ —Å–±–æ—Ä–æ—á–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è: ${base}${path}`);
    const resp = await axios.get(`${base}${path}`, { headers: { Authorization: apiKey } });
    console.log(`üìä –û—Ç–≤–µ—Ç WB FBS /orders/new:`, {
      status: resp.status,
      dataType: Array.isArray(resp.data) ? 'array' : typeof resp.data,
      dataLength: Array.isArray(resp.data) ? resp.data.length : (resp.data?.orders?.length || resp.data?.data?.length || 0),
      sample: Array.isArray(resp.data) ? resp.data[0] : (resp.data?.orders?.[0] || resp.data?.data?.[0] || null)
    });
    const data = resp.data;
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.orders)) return data.orders;
    if (data && Array.isArray(data.data)) return data.data;
    return [];
  } catch (e) {
    console.error(`‚ùå WB FBS /orders/new error:`, e.response?.data || e.message);
    
    // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ "token scope not allowed"
    if (e.response?.status === 401 && e.response?.data?.detail === 'token scope not allowed') {
      console.error('üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –¢–æ–∫–µ–Ω –Ω–µ –∏–º–µ–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –¥–ª—è Marketplace API');
      console.error('üìã –†–ï–®–ï–ù–ò–ï:');
      console.error('1. –ó–∞–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç Wildberries');
      console.error('2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ü—Ä–æ—Ñ–∏–ª—å ‚Üí –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ ‚Üí API');
      console.error('3. –°–æ–∑–¥–∞–π—Ç–µ –ù–û–í–´–ô —Ç–æ–∫–µ–Ω —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π "Marketplace"');
      console.error('4. –û–±–Ω–æ–≤–∏—Ç–µ API –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —Å–∏—Å—Ç–µ–º—ã');
      console.error('5. –¢–µ–∫—É—â–∏–π —Ç–æ–∫–µ–Ω –º–æ–∂–µ—Ç –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –¥–ª—è Statistics API');
    }
    
    return [];
  }
}

async function fetchWbFbsStatuses(apiKey, ids) {
  if (!ids || ids.length === 0) return [];
  const base = 'https://marketplace-api.wildberries.ru/api/v3';
  const path = '/orders/status';
  const headers = { 'Authorization': apiKey, 'Content-Type': 'application/json' };
  const flat = (ids || []).filter(Boolean);
  const unique = Array.from(new Set(flat.map(v => String(v).trim()).filter(v => v.length > 0)));
  try {
    console.log(`üîé FBS: —Å—Ç–∞—Ç—É—Å—ã –¥–ª—è ${unique.length} –∑–∞–¥–∞–Ω–∏–π`);
    // 1) —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —á–∏—Å–ª–∞ (–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç)
    const asNums = unique
      .map(v => Number(v))
      .filter(n => Number.isFinite(n) && n > 0);
    if (asNums.length > 0) {
      try {
        const rNum = await axios.post(`${base}${path}`, { orders: asNums }, { headers });
        return rNum.data?.orders || [];
      } catch (eNum) {
        const bodyNum = eNum.response?.data;
        if (!bodyNum || bodyNum.code !== 'IncorrectRequestBody') throw eNum;
      }
    }

    // 2) –∑–∞—Ç–µ–º —Å—Ç—Ä–æ–∫–∏
    try {
      const rStr = await axios.post(`${base}${path}`, { orders: unique }, { headers });
      return rStr.data?.orders || [];
    } catch (eStr) {
      const bodyStr = eStr.response?.data;
      if (!bodyStr || bodyStr.code !== 'IncorrectRequestBody') throw eStr;
    }

    // 3) –∑–∞—Ç–µ–º –æ–±—ä–µ–∫—Ç—ã { id } –∫–∞–∫ —á–∏—Å–ª–∞
    const asObjects = unique.map(id => ({ id: Number(id) }));
    const rObj = await axios.post(`${base}${path}`, { orders: asObjects }, { headers });
    return rObj.data?.orders || [];
  } catch (e) {
    console.error('‚ùå FBS statuses error:', e.response?.data || e.message);
    
    // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ "token scope not allowed"
    if (e.response?.status === 401 && e.response?.data?.detail === 'token scope not allowed') {
      console.error('üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –¢–æ–∫–µ–Ω –Ω–µ –∏–º–µ–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –¥–ª—è Marketplace API');
      console.error('üìã –†–ï–®–ï–ù–ò–ï:');
      console.error('1. –ó–∞–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç Wildberries');
      console.error('2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ü—Ä–æ—Ñ–∏–ª—å ‚Üí –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ ‚Üí API');
      console.error('3. –°–æ–∑–¥–∞–π—Ç–µ –ù–û–í–´–ô —Ç–æ–∫–µ–Ω —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π "Marketplace"');
      console.error('4. –û–±–Ω–æ–≤–∏—Ç–µ API –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —Å–∏—Å—Ç–µ–º—ã');
      console.error('5. –¢–µ–∫—É—â–∏–π —Ç–æ–∫–µ–Ω –º–æ–∂–µ—Ç –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –¥–ª—è Statistics API');
    }
    
    return [];
  }
}

async function fetchWbFbsOrdersClient(apiKey, ids) {
  if (!ids || ids.length === 0) return [];
  const base = 'https://marketplace-api.wildberries.ru/api/v3';
  const path = '/orders/client';
  const headers = { 'Authorization': apiKey, 'Content-Type': 'application/json' };
  const unique = Array.from(new Set(ids.map(String)));
  try {
    console.log(`üîé FBS: –∑–∞–∫–∞–∑—ã —Å –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –¥–ª—è ${unique.length} –∑–∞–¥–∞–Ω–∏–π`);
    try {
      const r1 = await axios.post(`${base}${path}`, { orders: unique }, { headers });
      return r1.data?.orders || [];
    } catch (e1) {
      const body = e1.response?.data;
      if (!body || body.code !== 'IncorrectRequestBody') throw e1;
      const asNums = unique.map(v => Number.isFinite(Number(v)) ? Number(v) : v);
      try {
        const r2 = await axios.post(`${base}${path}`, { orders: asNums }, { headers });
        return r2.data?.orders || [];
      } catch (e2) {
        const body2 = e2.response?.data;
        if (!body2 || body2.code !== 'IncorrectRequestBody') throw e2;
        const r3 = await axios.post(`${base}${path}`, { orders: unique.map(id => ({ id })) }, { headers });
        return r3.data?.orders || [];
      }
    }
  } catch (e) {
    console.error('‚ùå FBS orders/client error:', e.response?.data || e.message);
    return [];
  }
}

// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –º–µ—Ç–∞ –ø–æ —Ç–æ–≤–∞—Ä–∞–º –∏–∑ statistics-api –ø–æ nmId (subject/brand/supplierArticle)
async function fetchWbProductMetaByNmIds(apiKey, nmIds, opts = {}) {
  const metaMap = new Map();
  if (!nmIds || nmIds.length === 0) return metaMap;
  try {
    const unique = Array.from(new Set(nmIds.filter(n => Number.isFinite(Number(n))).map(n => Number(n))));
    if (unique.length === 0) return metaMap;

    const now = new Date();
    // –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
    const dateTo = opts.dateTo || now.toISOString().split('T')[0];
    const dateFrom = opts.dateFrom || new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    const resp = await axios.get('https://statistics-api.wildberries.ru/api/v1/supplier/orders', {
      headers: { Authorization: apiKey },
      params: { dateFrom, dateTo }
    });

    const rows = Array.isArray(resp.data) ? resp.data : (resp.data?.data || []);
    for (const r of rows) {
      const nm = Number(r.nmId || r.nmid || r.nmID);
      if (!Number.isFinite(nm)) continue;
      if (!unique.includes(nm)) continue;
      if (!metaMap.has(nm)) {
        metaMap.set(nm, {
          subject: r.subject || undefined,
          brand: r.brand || undefined,
          name: r.subject && r.brand ? `${r.subject} (${r.brand})` : (r.subject || r.brand || undefined),
          supplierArticle: r.supplierArticle || r.article || undefined
        });
      }
    }
  } catch (e) {
    // —Ç–∏—Ö–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º, –º–µ—Ç–∞ –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∞
  }
  return metaMap;
}

function normalizeWbOrder(raw, orderType) {
  // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–∫–∞–∑–∞ (–¥–ª—è orders/new —ç—Ç–æ –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ id)
  const orderId = raw.gNumber || raw.srid || raw.id || raw.orderId || raw.orderID || raw.orderUid || String(Date.now());

  // –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: –≤ orders/new –¥–ª—è FBS/DBW/DBS –ø–æ–ª–µ createdAt
  let createdAt = new Date().toISOString();
  if (raw.createdAt) {
    createdAt = new Date(raw.createdAt).toISOString();
  } else if (raw.date) {
    createdAt = typeof raw.date === 'number' ? new Date(raw.date).toISOString() : new Date(raw.date).toISOString();
  }

  // –°—É–º–º–∞ (—Å—ã—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ WB)
  const total =
    (typeof raw.finalPrice === 'number' && raw.finalPrice) ||
    (typeof raw.salePrice === 'number' && raw.salePrice) ||
    (typeof raw.price === 'number' && raw.price) ||
    (typeof raw.finishedPrice === 'number' && raw.finishedPrice) || 0;

  // –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É pricing: —Å—ã—Ä—ã–µ –∏ –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  const pricing = {
    salePrice: raw.salePrice ?? null,
    price: raw.price ?? null,
    convertedPrice: raw.convertedPrice ?? null,
    finalPrice: raw.finalPrice ?? null,
    convertedFinalPrice: raw.convertedFinalPrice ?? null,
    formatted: {
      salePrice: formatDropTwoZeros(raw.salePrice),
      price: formatDropTwoZeros(raw.price),
      convertedPrice: formatDropTwoZeros(raw.convertedPrice),
      finalPrice: formatDropTwoZeros(raw.finalPrice),
      convertedFinalPrice: formatDropTwoZeros(raw.convertedFinalPrice),
      totalAmount: formatDropTwoZeros(total)
    }
  };

  // –ê–¥—Ä–µ—Å: DBW –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç address.fullAddress, FBS –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å offices/officeId
  let deliveryAddress = '–ù–µ —É–∫–∞–∑–∞–Ω';
  if (raw.address && (raw.address.fullAddress || raw.address.address)) {
    deliveryAddress = raw.address.fullAddress || raw.address.address;
  } else if (Array.isArray(raw.offices) && raw.offices.length > 0) {
    deliveryAddress = `–ü–í–ó: ${raw.offices[0]}`;
  } else if (raw.regionName || raw.oblastOkrugName) {
    deliveryAddress = `${raw.regionName || ''}${raw.oblastOkrugName ? ', ' + raw.oblastOkrugName : ''}`.replace(/^,\s*|,\s*$/g, '') || '–ù–µ —É–∫–∞–∑–∞–Ω';
  }

  // –¢–æ–≤–∞—Ä: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ –∏–∑ nmId/chrtId/article
  const itemNameBase = raw.subject || '–¢–æ–≤–∞—Ä';
  const itemBrand = raw.brand ? ` (${raw.brand})` : '';
  const itemName = `${itemNameBase}${itemBrand}`.trim();
  const article = raw.supplierArticle || raw.article || raw.nmId?.toString() || 'unknown';
  const subject = raw.subject || undefined;
  const brand = raw.brand || undefined;
  const nmId = raw.nmId || undefined;
  const chrtId = raw.chrtId || undefined;
  const skus = Array.isArray(raw.skus) ? raw.skus : (raw.sku ? [raw.sku] : undefined);
  const orderUid = raw.orderUid || undefined;
  const rid = raw.rid || undefined;

  return {
    orderId: String(orderId),
    marketplace: 'wildberries',
    status: 'new',
    totalAmount: total,
    customerName: '–ö–ª–∏–µ–Ω—Ç Wildberries',
    customerPhone: '',
    customerEmail: '',
    deliveryAddress,
    items: [
      {
        article,
        name: itemName,
        quantity: 1,
        price: total,
        totalPrice: total,
        priceFormatted: pricing.formatted.price || pricing.formatted.finalPrice || pricing.formatted.totalAmount,
        totalPriceFormatted: pricing.formatted.totalAmount,
        subject,
        brand,
        nmId,
        chrtId,
        skus,
        orderUid,
        rid
      }
    ],
    orderDate: createdAt,
    orderType,
    pricing
  };
}

async function upsertOrders(clientId, orders) {
  if (!orders || orders.length === 0) return 0;
  const client = await pool.connect();
  try {
    let saved = 0;
    for (const o of orders) {
      try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∑–∞–∫–∞–∑
        const existingOrderResult = await client.query(
          'SELECT id, status FROM orders WHERE client_id = $1 AND marketplace_order_id = $2 AND marketplace = $3',
          [clientId, o.orderId, o.marketplace]
        );

        const isNewOrder = existingOrderResult.rows.length === 0;
        const existingOrder = existingOrderResult.rows[0];

        await client.query(
          `INSERT INTO orders (client_id, marketplace_order_id, marketplace, status, total_amount, customer_name, customer_phone, customer_email, delivery_address, items, created_at, order_type)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
           ON CONFLICT (client_id, marketplace_order_id, marketplace) DO UPDATE SET
             status = EXCLUDED.status,
             total_amount = EXCLUDED.total_amount,
             customer_name = EXCLUDED.customer_name,
             customer_phone = EXCLUDED.customer_phone,
             customer_email = EXCLUDED.customer_email,
             delivery_address = EXCLUDED.delivery_address,
             items = EXCLUDED.items,
             order_type = EXCLUDED.order_type,
             updated_at = CURRENT_TIMESTAMP`,
          [
            clientId,
            o.orderId,
            o.marketplace,
            o.status,
            o.totalAmount,
            o.customerName,
            o.customerPhone,
            o.customerEmail,
            o.deliveryAddress,
            JSON.stringify(o.items),
            o.orderDate || new Date().toISOString(),
            o.orderType || 'FBS'
          ]
        );

        // –ï—Å–ª–∏ —ç—Ç–æ –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑ –∏–ª–∏ –∑–∞–∫–∞–∑ –∏–∑–º–µ–Ω–∏–ª —Å—Ç–∞—Ç—É—Å –Ω–∞ "–Ω–æ–≤—ã–π", –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–ª–∞—Ç–µ–∂
        if (isNewOrder || (existingOrder && existingOrder.status !== 'new' && o.status === 'new')) {
          try {
            const paymentResult = await orderPaymentService.processOrderPayment(clientId, o);
            if (paymentResult.success) {
              console.log(`Payment processed for order ${o.orderId}: ${paymentResult.amount} ‚ÇΩ`);
            } else {
              console.warn(`Payment failed for order ${o.orderId}: ${paymentResult.error}`);
            }
          } catch (paymentError) {
            console.error(`Payment processing error for order ${o.orderId}:`, paymentError);
          }
        }

        saved++;
      } catch (e) {
        console.error('Upsert order error:', e.message);
      }
    }
    return saved;
  } finally {
    client.release();
  }
}

async function autoImportOrders() {
  const client = await pool.connect();
  try {
    const users = await client.query('SELECT id FROM users WHERE is_active = true');
    for (const row of users.rows) {
      try {
        const clientRes = await client.query('SELECT id, api_keys FROM clients WHERE user_id = $1', [row.id]);
        if (clientRes.rows.length === 0) continue;
        const clientId = clientRes.rows[0].id;
        const apiKeys = clientRes.rows[0].api_keys || {};
        const wbKey = apiKeys.wildberries?.api_key;
        if (!wbKey) continue;

        console.log(`üîÑ –ò–º–ø–æ—Ä—Ç WB –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${row.id} (client_id: ${clientId})`);

        // 1) –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–µ –∑–∞–¥–∞–Ω–∏—è FBS
        const fbsNew = await fetchWbNewFbs(wbKey);
        console.log(`üì¶ FBS –Ω–æ–≤—ã–µ: ${fbsNew.length}`);

        // 2) –¢—è–Ω–µ–º —Å—Ç–∞—Ç—É—Å—ã –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã –∫–∞—Ä—Ç–∏–Ω—ã (supplierStatus/wbStatus)
        const fbsIds = fbsNew.map(o => o.id || o.orderId || o.orderID || o.orderUid).filter(Boolean);
        const fbsStatuses = await fetchWbFbsStatuses(wbKey, fbsIds);
        const statusMap = new Map();
        for (const s of fbsStatuses) statusMap.set(String(s.id), s);

        // 3) –¢—è–Ω–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∫–∞–∑–µ —Å –¥–∞–Ω–Ω—ã–º–∏ –∫–ª–∏–µ–Ω—Ç–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
        const fbsWithClient = await fetchWbFbsOrdersClient(wbKey, fbsIds);
        const clientMap = new Map();
        for (const c of fbsWithClient) clientMap.set(String(c.id), c);

        // 4) –¢—è–Ω–µ–º –º–µ—Ç—É –ø–æ nmId –¥–ª—è –∏–º–µ–Ω–∏/–∫–∞—Ç–µ–≥–æ—Ä–∏–∏/–±—Ä–µ–Ω–¥–∞/–∞—Ä—Ç–∏–∫—É–ª–∞
        const nmIds = fbsNew.map(o => o.nmId).filter(Boolean);
        // –º–µ—Ç–∞ —Å—Ç—Ä–æ–≥–æ –∑–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        const metaByNm = await fetchWbProductMetaByNmIds(wbKey, nmIds, { dateFrom: todayStr, dateTo: todayStr });

        const toSave = fbsNew.map(r => {
          const o = normalizeWbOrder(r, 'FBS');
          const sid = String(r.id || r.orderId || r.orderID || r.orderUid);
          const st = statusMap.get(sid);
          if (st) {
            o.supplierStatus = st.supplierStatus || null;
            o.wbStatus = st.wbStatus || null;
            if (Array.isArray(o.items) && o.items.length > 0) {
              o.items[0].supplierStatus = st.supplierStatus || null;
              o.items[0].wbStatus = st.wbStatus || null;
              // —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏
              const supplierStatusTextMap = {
                new: '–ù–æ–≤–æ–µ —Å–±–æ—Ä–æ—á–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ',
                confirm: '–ù–∞ —Å–±–æ—Ä–∫–µ',
                complete: '–í –¥–æ—Å—Ç–∞–≤–∫–µ',
                cancel: '–û—Ç–º–µ–Ω–µ–Ω–æ –ø—Ä–æ–¥–∞–≤—Ü–æ–º'
              };
              const wbStatusTextMap = {
                waiting: '–í —Ä–∞–±–æ—Ç–µ',
                sorted: '–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ',
                sold: '–ü–æ–ª—É—á–µ–Ω–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º',
                canceled: '–û—Ç–º–µ–Ω–µ–Ω–æ',
                canceled_by_client: '–û—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏',
                declined_by_client: '–û—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º (–≤ –ø–µ—Ä–≤—ã–π —á–∞—Å)',
                defect: '–û—Ç–º–µ–Ω–µ–Ω–æ (–±—Ä–∞–∫)',
                ready_for_pickup: '–ü—Ä–∏–±—ã–ª–æ –≤ –ü–í–ó'
              };
              o.items[0].supplierStatusText = supplierStatusTextMap[st.supplierStatus] || null;
              o.items[0].wbStatusText = wbStatusTextMap[st.wbStatus] || null;
            }
          }
          const cd = clientMap.get(sid);
          if (cd) {
            // –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–º–∏ –∫–ª–∏–µ–Ω—Ç–∞, –µ—Å–ª–∏ WB –≤–µ—Ä–Ω—É–ª
            if (cd.client) {
              o.customerName = [cd.client.lastName, cd.client.firstName].filter(Boolean).join(' ') || o.customerName;
              o.customerPhone = cd.client.phone || o.customerPhone;
              o.customerEmail = cd.client.email || o.customerEmail;
            }
            if (cd.address && (cd.address.fullAddress || cd.address.address)) {
              o.deliveryAddress = cd.address.fullAddress || cd.address.address;
            }
          }
          // –û–±–æ–≥–∞—â–∞–µ–º —Ç–æ–≤–∞—Ä–Ω–æ–π –º–µ—Ç–æ–π, –µ—Å–ª–∏ –µ—Å—Ç—å nmId
          if (r.nmId) {
            const meta = metaByNm.get(Number(r.nmId));
            if (meta) {
              const name = meta.name || o.items?.[0]?.name;
              const article = meta.supplierArticle || o.items?.[0]?.article;
              if (Array.isArray(o.items) && o.items.length > 0) {
                o.items[0].name = name || o.items[0].name;
                o.items[0].article = article || o.items[0].article;
                o.items[0].subject = meta.subject || o.items[0].subject;
                o.items[0].brand = meta.brand || o.items[0].brand;
              }
            }
          }
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º id —Å–±–æ—Ä–æ—á–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è –≤–Ω—É—Ç—Ä—å items –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ —Ä–∞–±–æ—Ç—ã –≤ UI/–æ—Ç—á—ë—Ç–∞—Ö
          if (Array.isArray(o.items) && o.items.length > 0) {
            o.items[0].assignmentId = sid;
            o.items[0].orderType = 'FBS';
          }
          return o;
        });

        // –ü–æ–¥—Ä–æ–±–Ω—ã–µ –ª–æ–≥–∏ –ø–æ –∫–∞–∂–¥–æ–º—É –∑–∞–∫–∞–∑—É (–ø–æ—Å–ª–µ –æ–±–æ–≥–∞—â–µ–Ω–∏—è)
        for (const o of toSave) {
          const it = Array.isArray(o.items) && o.items[0] ? o.items[0] : {};
          console.log('üßæ WB –∑–∞–∫–∞–∑ (enriched):', {
            orderId: o.orderId,
            assignmentId: it.assignmentId || null,
            orderType: it.orderType || o.orderType || 'FBS',
            item: {
              name: it.name || null,
              subject: it.subject || null,
              brand: it.brand || null,
              article: it.article || null,
              nmId: it.nmId || null,
              chrtId: it.chrtId || null,
              skus: it.skus || null
            },
            pricing: {
              totalAmount: o.totalAmount,
              price: it.price,
              totalPrice: it.totalPrice,
              formatted: o.pricing?.formatted || null
            },
            statuses: {
              supplierStatus: it.supplierStatus || o.supplierStatus || null,
              supplierStatusText: it.supplierStatusText || null,
              wbStatus: it.wbStatus || o.wbStatus || null,
              wbStatusText: it.wbStatusText || null
            },
            deliveryAddress: o.deliveryAddress
          });
        }

        console.log(`üîÑ –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∑–∞–∫–∞–∑–æ–≤: ${toSave.length}`);
        if (toSave.length > 0) {
          const saved = await upsertOrders(clientId, toSave);
          console.log(`‚úÖ WB import –∑–∞–≤–µ—Ä—à–µ–Ω: user ${row.id}, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${saved}/${toSave.length}`);
        } else {
          console.log(`‚ÑπÔ∏è –ù–µ—Ç –Ω–æ–≤—ã—Ö –∑–∞–∫–∞–∑–æ–≤ —á–µ—Ä–µ–∑ /orders/new –¥–ª—è user ${row.id}`);
        }

        // 5) –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å—ã —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö ¬´–Ω–æ–≤—ã—Ö¬ª –∑–∞–∫–∞–∑–æ–≤ –≤ –Ω–∞—à–µ–π –ë–î,
        // —á—Ç–æ–±—ã –æ–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å—á–µ–∑–∞–ª–∏ —Å –≤–∫–ª–∞–¥–∫–∏ "–ó–∞–∫–∞–∑—ã" –∏ –ø–æ–ø–∞–¥–∞–ª–∏ –≤ –∏—Å—Ç–æ—Ä–∏—é
        try {
          const openRes = await client.query(
            `SELECT id, marketplace_order_id, items, order_type, created_at
             FROM orders
             WHERE client_id = $1
               AND marketplace = 'wildberries'
               AND status = 'new'
               AND order_type = 'FBS'
               AND created_at > NOW() - INTERVAL '30 days'`,
            [clientId]
          );
          const openOrders = openRes.rows || [];
          if (openOrders.length > 0) {
            const ids = [];
            for (const o of openOrders) {
              // –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å assignmentId –∏–∑ items[0], –∏–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º marketplace_order_id,
              // –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä WB –∑–∞–¥–∞–Ω–∏—è
              let itemFirst = Array.isArray(o.items) && o.items[0] ? o.items[0] : null;
              let candidate = itemFirst && itemFirst.assignmentId ? itemFirst.assignmentId : o.marketplace_order_id;
              const asNum = Number(candidate);
              if (Number.isFinite(asNum) && asNum > 1000000000) {
                ids.push(asNum);
              }
            }
            if (ids.length === 0) {
              console.log('‚ÑπÔ∏è –ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö FBS ID –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ (–ø—Ä–æ–ø—É—â–µ–Ω—ã —Å—Ç–∞—Ä—ã–µ gNumber –∏ –Ω–µ—á–∏—Å–ª–æ–≤—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã)');
            }
            const latestStatuses = await fetchWbFbsStatuses(wbKey, ids);
            const latestMap = new Map();
            for (const s of latestStatuses || []) latestMap.set(String(s.id), s);

            const mapWbToAppStatus = (supplierStatus, wbStatus) => {
              // –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–∞–≤–∏–ª–æ:
              // - supplierStatus=new -> new
              // - supplierStatus=confirm -> in_assembly
              // - supplierStatus=complete -> shipped
              // - supplierStatus=cancel -> cancelled
              // –î–æ–ø. –ø–æ wbStatus: sold -> delivered
              if (wbStatus === 'sold') return 'delivered';
              if (supplierStatus === 'cancel') return 'cancelled';
              if (supplierStatus === 'complete') return 'shipped';
              if (supplierStatus === 'confirm') return 'in_assembly';
              return 'new';
            };

            for (const ord of openOrders) {
              const st = latestMap.get(String(ord.marketplace_order_id));
              if (!st) continue;
              const newStatus = mapWbToAppStatus(st.supplierStatus, st.wbStatus);
              if (newStatus !== 'new') {
                try {
                  // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏–º —Å—Ç–∞—Ç—É—Å—ã –∏ –≤–Ω—É—Ç—Ä–∏ –ø–µ—Ä–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                  let items = Array.isArray(ord.items) ? ord.items : [];
                  if (items.length > 0) {
                    items = items.map((it, idx) => idx === 0 ? {
                      ...it,
                      supplierStatus: st.supplierStatus || it.supplierStatus || null,
                      wbStatus: st.wbStatus || it.wbStatus || null
                    } : it);
                  }
                  await client.query(
                    `UPDATE orders SET status = $1, items = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3`,
                    [newStatus, JSON.stringify(items), ord.id]
                  );
                  console.log(`‚Ü™Ô∏è –û–±–Ω–æ–≤–ª–µ–Ω —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ ${ord.marketplace_order_id} -> ${newStatus}`);
                } catch (e) {
                  console.error('Update status error:', e.message);
                }
              }
            }
          }
        } catch (e) {
          console.error('Refresh WB statuses error:', e.message);
        }
      } catch (e) {
        console.error('Hourly WB import error for user', row.id, e.message);
      }
    }
  } finally {
    client.release();
  }
}

module.exports = { autoImportOrders };


